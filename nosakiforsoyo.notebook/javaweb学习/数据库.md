### 2025.11.23

	采用图形化工具navicat和mysql。

	数据类型大致可以分为五类：
	数值型： TINYINT(最大255),INT,BIGINT,DECIMAL(10,2)(10总位，2小数位)
		字符串型：CHAR(n)(n最大255)，VARCHAR(n)(可自动变短型)，TEXT(长文本)，LONGTEXT(超长文本)
	日期型：DATE(年月日)，TIME(时分秒)，DATETIME(年月日+时分秒)，TIMESTAMP(时区自动切换的DATETIME)
	布尔类型：BOOLEAN，BIT(n)(位字段，n最大64)
	json类型：JSON(用于取代TEXT+手动解析)

```
建表
create table player(
  id INT,
  name VARCHAR(100),
  level INT,
  exp INT,
  Gold DECIMAL(10,2)
);
查看表状态
Desc player;
修改表结构
ALTER table player MODIFY COLUMN name VARCHAR(200);
表结构改名
ALTER table player RENAME COLUMN name to nick_name;
增加表结构
ALTER table player ADD COLUMN last_login DATETIME;
删除表结构
ALTER TABLE player DROP COLUMN last_login;
删除表
DROP table player;
```

对表中数据进行操作
```
增
Insert INTo player (id,name) VALUES(1,"张三");
Insert into player (id,name) values(2,"李四"),(3,'王五');
查
select * from player;
设定某类型的默认值
Alter table player modify level INT DEFAULT 1;
更新
update player set level = 1 where name = '张三';
update player set exp = 0;
update player set Gold = 0;
删
delete from player where Gold = 0;

```
然后是从cmd中导入导出.sql文件
```
导出
mysqldump -u root -p game > game.sql
导入
mysql -u root -p game < game.sql
```

然后是逻辑顺序：NOT > AND >OR
```
SELECT * FROM player WHERE level > 1 OR level < 5 AND level = 10;
IN表查找特定数值
SELECT * FROM player WHERE level IN(1,3,5);
between表范围
SELECT * FROM player WHERE level BETWEEN 1 AND 10;
在逻辑符号前加not表非
SELECT * FROM player WHERE level NOT BETWEEN 1 AND 10;
like表存在某字符
SELECT * FROM player WHERE name LIKE "%秦%"
加n个下划线匹配n位数的名字
SELECT * FROM player WHERE name LIKE "秦_";(表两位)

之后是和正则表达式联动，不多说了，学不会
SELECT * FROM player WHERE name REGEXP '^王.$';
```
mysql中null与任何值都不想等，所以查询的时候不使用=，要使用is
```
SELECT * FROM player WHERE name IS null;
SELECT * FROM player WHERE name IS NOT null;
```
查找排序
```
升序
SELECT * FROM player ORDER BY level;
降序
SELECT * FROM player ORDER BY level DESC;
主列和次列(次列默认升序，ASC表升序，DESC降序)
SECLECT * FROM player OREDER BY level ,exp ASC
```
聚合函数用于数值计算之类的内容
![[Pasted image 20251123234825.png]]
```
SELECT COUNT(*) FROM player;

SELECT AVG(level) FROM player;

分组查询
SELECT sex，COUNT(*) FROM player group by sex;
SELECT level,COUNT(level) FROM player group by level;
使用having来过滤部分数据
SELECT level,count(level) from player group by level having count(level)>=4

```
having和where，having是先进行分组再来筛选，where是先筛选之后进行其他操作

限制输出
```
SELECT 
  SUBSTR(name , 1 , 1) ,count(SUBSTR(name,1,1)) 
FROM 
  player GROUP BY SUBSTR(name,1,1) 
ORDER BY
  COUNT(SUBSTR(name,1,1)) 
  DESC
LIMIT
  3,3
LIMIT表示限制数量，LIMIT 3表示限制为前三个，LIMIT 4,3 表示从第四个开始限制
```
去重DISTINCT
```
SELECT DISTINCT sex FROM player;
```
UNION***合并查询结果集***,默认去重，可换为UNION ALL 强制不去重
```
SELECT 
	* 
FROM 
	player
where
	level>=10
UNION SELECT
	*
FROM
	player
where
	name like '王_'
;
```
INTERSECT***查找结果交集***,取交集
```
SELECT 
	* 
FROM 
	player
where
	level>=10
INTERSECT SELECT
	*
FROM
	player
where
	name like '王_'
;
```
EXCPEPT查找减集，排除后续的查询结果
```
SELECT 
	* 
FROM 
	player
where
	level>=10
EXCEPT SELECT
	*
FROM
	player
where
	name like '王_'
;
```

### 子查询
```
先查询表的level的平均数然后再找大于平均数的
SELECT * from player WHERE level > (SELECT AVG(level) FROM player);
将子查询包裹以变为子表再传参，as来改名字
SELECT 
  level
  ,ROUND((SELECT AVG(level) FROM player)) as average
  ,level - ROUND((SELECT AVG(level) FROM player)) as diff
FROM player
```
可以从表格中选择特定元素创建新表格
```
CREATE TABLE sub_player SELECT
  *
FROM
  player
WHERE
  LEVEL <= 3;
```
也可以用insert into对新表插入父表的数据
```
INSERT into sub_player SELECT * FROM player WHERE level>50;
```
exists可以查询某条件下的数据是否存在
```
SELECT EXISTS(SELECT * FROM player WHERE level>1000)
```
### 表链接

存在三个用于链接的关键字：
	INNER JOIN
	LEFT JOIN
	RIGHT JOIN

```
都有才会显示
SELECT * FROM player
INNER JOIN equip
on player.id = equip.player_id

将右表的数据填充进左表，无则为null
SELECT * FROM player
LEFT JOIN equip
on player.id = equip.player_id

将左表的数据填充进右表。无则null
SELECT * FROM player
RIGHT JOIN equip
on player.id = equip.player_id
```
```
改个名字
SELECT * FROM player p, equip e
where player.id = equip.player_id

SELECT * FROM player, equip
where player.id = equip.player_id

```
### 索引
用于加快 较大数据库的查询
```
创建索引
CREATE INDEX email_index on player(email);
查看某表的索引
SHOW INDEX from player;
删除某表的索引
DROP INDEX email_index ON player;

在修改表的时候创建表
ALTER table player add INDEX name_index (name);
```

### 视图
视图是动态查询的，每次更改表都会改变视图
```
创建
CREATE VIEW tool1 
	as select * from player order by level desc limit 10; 
修改
ALTER VIEW tool1
  as select * from player order by level desc limit 2; 
删除
DROP VOEW tool1
```